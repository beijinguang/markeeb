# 32个JAVA面试必考点

## 一.操作系统与计算机网络

### 1.进程与线程的区别和联系

​	进程是系统资源分配的最小单位，线程是程序执行的最小单位；

​	进程使用独立的数据空间，而线程共享进程的数据空间。比如java启动时，本事就是一个进程，其中用多个线程在工作。

### 2.简单介绍一下进程的切换过程



### 3.你经常用哪些linux命令，用来解决哪些问题？



### 4.为什么tcp建立连接需要3次握手而断连需要4次？

<img src="https://gitee.com/idea4j/image4md/raw/master/images/image-20201004213552815.png" alt="image-20201004213552815" style="zoom:50%;" />

三次握手

第一次握手：客户端将标志位SYN（同步序列编号Synchronize Sequence Numbers）置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务端确认。

第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=k，并将该数据包发送给客户端已确认连接请求，服务端进入SYN_RCVD状态。

第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确就把标志位ACK置为1，ack=K+1，并将数据包发给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确，则连接建立成功。客户端和服务器端进入ESTABLISHED状态，完成三次握手，两端就可以传输数据了。

注意：可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击

<img src="https://gitee.com/idea4j/image4md/raw/master/images/image-20201004215013835.png" alt="image-20201004215013835" style="zoom:50%;" />

四次挥手

中断的可以是服务端也可以是客户端。

第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态，意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但我还没准备好，请你继续等我的消息。这个时候客户端就进入FIN_WAIT_2状态，继续等待服务端的FIN报文。

第三次挥手：当服务器端确定数据已经传输完成，则向客户端发送FIN=N的报文，告诉客户端，数据发送完毕了，准备好关闭连接了，服务器端进入LAST_ACK状态。

第四次挥手：客户端收到FIN=N时，就知道要关闭连接了，通知服务器端自己要关闭了，发送ack=N+1后进入TIME_WAIT状态，如果服务器端没有收到ACK则可以重传。服务器收到ACK后，就知道断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

可以提到实际应用中有可能遇到大量 Socket 处在 TIME_WAIT 或者 CLOSE_WAIT 状态的问题。一般开启 **tcp_tw_reuse** 和 **tcp_tw_recycle** 能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。

### 5.为什么tcp关闭连接时需要TIME_WAIT状态，为什么要等2MSL?

为什么需要等待 2 倍最大报文段生存时间之后再关闭链接，原因有两个：

保证 TCP 协议的全双工连接能够可靠关闭；

保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。

### 6.一次完整的http请求是怎样的？

**1.解析URL**

  首先浏览器会检测这个url是否正确存在，如果不合法，将会返回一个默认的搜索引擎。

  如果存在并合法，那么可以解析得到协议（http或者https）、域名（baidu）、资源（首页）等信息。

**2.DNS查询**

- 浏览器会先检查域名信息是否在缓存中。
- 再检查域名是否在本地的Hosts文件中。
- 如果还不在，那么浏览器会向DNS服务器发送一个查询请求，获得目标服务器的IP地址。



**3.TCP传输及运输**

这时候浏览器获得了目标服务器的IP（DNS返回）、端口（URL中包含，没有就使用默认（HTTP默认80端口）），浏览器会调用库函数socket，生成一个TCP流套接字，也就是完成了TCP的封包。

TCP封包完成之后，就可以传输了，浏览器和服务器就完成了TCP的三次握手，建立了连接，后面就可以请求服务器资源了。

**4.服务器接收请求并响应**

- HTTP有很多请求方法，比如：GET/POST/PUT/DELETE等等，我们浏览器输入URL这种，是GET方法。
- 服务器接收到GET请求，服务器根据请求信息，获得相应的相应内容。例如我们输入的是：\www.baidu.com\，那么意味着访问百度的首页文件

**5.浏览器解析并渲染**

浏览器从服务器拿到了想要访问的资源，大多数时候，这个资源就是HTML页面，当然也可能是一个其他类型的文件。

- 浏览器先对HTML文档进行解析，生成解析树（以DOM元素为节点的树）。
- 加载页面的外部资源，比如JS、CSS、图片。
- 遍历DOM树，并计算每个节点的样式，最终完成渲染，变成我们看到的页面。



### 7.http，https，http2的区别有哪些？

### 8.在你的项目中你使用过哪些设计模式，主要解决哪些问题？

### 9.Object中的equals和hashcode的作用是什么？

### 10.java的异常机制



### 11.网络的 4/7 层模型

应表会传网数物（应表回传王树屋）

![image-20201004213213211](/Users/wangjinguang/Library/Application Support/typora-user-images/image-20201004213213211.png)

## 二.JVM相关

### 1.jvm内存模型

jvm分为程序技术器、堆、栈、元空间、直接内存；

栈，虚拟机栈和本地方法栈

栈，也叫方法栈是线程私有的，线程执行每一个方法时都会创建一个栈帧，用来存储局部变量表，操作栈，动态链接，方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。

本地方法栈，与栈类似，也是保存线程执行方法时的信息，不同的是执行java方法使用栈，而执行native方法使用本地方法栈。

程序计数器保存着当前线程所执行字节码的位置，每个线程都有独立的计数器。

堆是jvm最大的一块，堆被所有的线程共享，目的是为了存储对象实例，几乎所有对象的实例都在堆上分配，当堆内存没有空间时，会OOM异常。

方法区也是各个线程共享的区域，也叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。jdk1.7在永久代，jdk1.8在元空间。

直接内存，bytebuffer创建的内存

### 2.什么情况下会触发FullGC？

1. 老年代空间不足时
2. 主动调用System.gc()时
3. 方法区空间不足时，或 Metaspace Space 使用达到 MetaspaceSize 但未达到 MaxMetaspaceSize 阈值；大多情况下扩容都会触发；
4. concurrent mode failure ；



### 3.java的类加载器有哪几种？关系是怎样的？

BootstrapClassLoader启动类加载器（<JAVA_HOME>/lib）

ExtClassLoader扩展类加载器（<JAVA_HOME>/lib/ext）

AppClassLoader应用加载器(classpath)

CustomClassLoader自定义加载器

### 4.双亲委派机制的加载流程是怎样的，有什么好处？

双亲委派模式，一个类加载器在加载类时，首先会把这个请求委托给父类去执行，如果父类加载器还存在父类再继续向上委托，直到顶层就是启动类加载器。如果父类加载器能够完成类加载，就成功返回，如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载。双亲委派模式避免了类的重复加载，也避免了核心api被篡改。

### 5.jdk1.8为什么用metaspace替换掉permGen？metaspace保存在哪里？

1. 移除永久代是为融合HotSpot JVM与JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。
2. 现实使用中，由于永久代内存占用堆内存，运行时生成大量类的造成经常 Full GC，爆出异常java.lang.OutOfMemoryError : PermGen.而元空间占用的是堆外内存。



### 6.编译期会对哪些治指令进行优化？

jvm在编译代码的时候 ，为了提高程序运行效率，在不影响单线程程序执行结果的前提下，对指令进行的排序

前端编译器 javac 的编译过程、AST 抽象语法树、编译期优化和运行期优化。编译优化的常用技术包括公共子表达式的消除、方法内联、逃逸分析、栈上分配、同步消除等。明白了这些才能写出对编译器友好的代码。



### 7.volatile可以解决什么问题？是如何做到的？

volatile主要解决内存可见性的问题。jmm中，主内存有一个数据，每个线程都有自己的内存副本（工作内存），单个线程修改主内存的过程是先修改自己的内存副本再刷新到主内存中，这样就会出现线程安全问题。加上volatile关键字，线程修改volatile变量时，会强制刷新修改后的值到主内存中，并其他线程工作内存中的引用值失效，再读取该变量就必须重新从主内存中读取。

有序性，被volatile修饰的，会禁止指令重排；

### 8.GC的分代回收

垃圾回收算法：标记清除法，复制算法，标记整理法，分代算法；

为了高效率的进行内存回收。堆内存就划分成了几个区域：

年轻代，用来存放新创建的对象实例，年轻代有划分为eden和两个survivor空间，年轻代采用复制算法，效率高，这也是minorGC使用时间短的原因之一。

老年代，用来存放放年轻代晋升来存放时间长的对象。老年代采用标记清理法或者标志整理法。



### 9.G1回收算法和CMS的区别有哪些？

cms回收器执行步骤

1、初始标记：GC roots 可以理解为对象指向的标记

2、并发标记： GC roots Tracing 可以理解为 通过初始标记找到了要删除的对象 也就是堆中的指向对象

3、重新标记： 可以理解为重新执行了一遍 初始标记 和 并行标记 产生标记记录

4、删除标记：标记删除发进行并发删除

**优点**：并行执行，低停顿

**缺点**：

1、不停顿耗线程，耗内存，整体效率低

2、标记清除法会产生垃圾碎片 容易FGC

3、会产生浮动垃圾容易FGC

 

g1回收器：

1、初始标识：GC roots 可以理解为对象指向的标记 并且更改tame值出发并发标记

2、并发标记：GC roots Tracing 可以理解为 通过初始标记找到了要删除的对象 也就是堆中的指向对象

3、最终标记： 可以理解为重新执行了一遍 初始标记 和 并行标记 产生标记记录 将标记记录存到remember set log中，然后在合并到 remember set中，通过remember set 来管理对象的引用

4、筛选回收：通过Region区块对回收价值和成本进行排序，根据用户所希望的GC时间进行回收。

**优点**：

1、空间整合：g1使用Region独立区域概念，g1利用的是标记复制法，不会产生垃圾碎片

2、分代收集：g1可以自己管理新生代和老年代

3、并行于并发：g1可以通过机器的多核来并发处理 stop - The - world停顿，减少停顿时间，并且可不停顿java线程执行GC动作，可通过并发方式让GC和java程序同时执行。

4、可预测停顿：g1除了追求停顿时间，还建立了可预测停顿时间模型，能让制定的M毫秒时间片段内，消耗在垃圾回收器上的时间不超过N毫秒

最大的区别是出现了Region区块概念，可对回收价值和成本进行排序回收，根据GC期望时间回收，还出现了member set概念，

将回收对象放入其中，避免全堆扫描



### 10.对象引用有哪几种方式，有什么特点？

强引用：如果一个对象具有强引用，那么垃圾回收器绝不会回收他，当内存不足时，Java虚拟机宁愿抛出OutOfMemoryError错误，也不会回收强引用。

软引用：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

弱引用：弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

虚引用：“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。

### 11.使用过哪些jvm调试工具，主要分析哪些内容？

MAT：查看内存泄露，看镜像内堆内存的组成，查看对象的深堆和浅堆等

visualVm：查看jvm各个分区的占用情况，查看各个分区的时间曲线

jstack -l 查看死锁，jps等